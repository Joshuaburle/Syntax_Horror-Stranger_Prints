#!/usr/bin/env python3

import tkinter as tk
from functools import partial
import os
try:
    from PIL import Image, ImageTk
    HAS_PIL = True
except ImportError:
    HAS_PIL = False

def on_closing():
    # AFFICHE VISAGE MECONTENT
    text_var.set("> Vous ne pouvez pas quitter comme √ßa...")
    root.bell()  # Fait un son pour l'effet

STORY = {
    "start": {
        "text": """Jean-Michel Pointeur (v1.0)
         "image": "corner_image.png",
Bonjour üòä
Je suis Jean-Michel Pointeur, ton tuteur personnel pour comprendre simplement les pointeurs en C.
Ensemble, on va voir ce qu'est une adresse, comment lire et modifier une valeur via un pointeur, et adopter de bons r√©flexes de s√©curit√©. Youpi !

Prends ton temps, r√©ponds √† ton rythme : je t'explique tout pas √† pas.

Appuie sur ENTER pour commencer.""",
        "choices": [("Commencer", "enter_name")]
    },

    "enter_name": {
        "text": """Bienvenue dans cette aventure interactive !
Comment t'appelles-tu ?

Entrez votre nom :""",
        "input_key": "name",
        "choices": [("Valider", "first_question")]
    },

    "first_question": {
        "text": """L'adresse de variable, operateur&   
Une variable en C a une adresse en m√©moire. Pour obtenir cette adresse, on utilise l'op√©rateur &.
Selon toi que represente &n ?""",
        "choices": [
            ("L'adresse de la variable n", "second_question"),
            ("La valeur de la variable n", "cas_erreur")
        ]
    },

    "second_question": {
        "text": """D√©r√©ferencer un pointeur, c'est acc√©der √† la valeur stock√©e √† l'adresse point√©e. On utilise l'op√©rateur * pour cela.
Que fait l'expression *p si p est un pointeur vers un entier ?""",
        "choices": [
            ("Acc√®de √† la valeur enti√®re point√©e par p", "third_question"),
            ("Acc√®de √† l'adresse de p", "cas_erreur")
        ]
    },

    "third_question": {
        "text": """Q3 ‚Äî Comprendre l'envers.
Que fait l'expression &*p si p est un pointeur valide ?""",
        "choices": [
            ("Retourne la valeur stock√©e √† l'adresse de p", "jean_michel_enerve"),
            ("Retourne l'adresse point√©e par p", "strange_question")
        ]
    },
#PLACEHOLDER VISAGE MECONTENT
    "cas_erreur": {
        "text": """Oups ! Non, il semble que tu te sois tromp√©. Reprenons ensemble pour bien comprendre.""",
        "image": "corner_image_mecontent.png",
        "choices": [("Recommencer", "first_question")]
    },

#PLACEHOLDER VISAGE EN COLERE
    "jean_michel_enerve": {
        "text": """Jean-Michel Pointeur (v1.1)
√áa suffit les erreurs ! On va tout reprendre depuis le d√©but.
Cette fois, tu vas √©couter attentivement et suivre mes instructions √† la lettre. Pas de place pour l'erreur cette fois-ci !""",
        "image": "corner_image_colere.png",
        "choices": [("Recommencer", "third_question")]
    },
#PLACEHOLDER VISAGE NORMAL
    "strange_question": {
        "text": """Si tu ne pouvais sauver qu'une personne, tu choisirais de sauver :""",
        "image": "corner_image.png",
        "choices": [
            ("Un(e) ami(e)", "end"),
            ("Un(e) membre de ta famille", "end")
        ]
    },

    "end": {
        "text" : """Est-ce-que-tu-pr√©f√®res :""",
        "image": "visage_horrible.png",
        "choices": [
            ("Me rejoindre?", "end"),
            ("Ou que je vienne te chercher :)?", "end")
        ]
#PLACEHOLDER VISAGE HORRIBLE (SCREAMEUR)
        }
    }

root = tk.Tk()
root.title("Terminal")
root.geometry("960x600")
root.configure(bg='black')
root.protocol("WM_DELETE_WINDOW", on_closing)  # Intercepte la croix

# Layout principal en grille (responsive)
root.grid_columnconfigure(0, weight=0)  # colonne image
root.grid_columnconfigure(1, weight=1)  # colonne texte/boutons
root.grid_rowconfigure(0, weight=1)     # ligne texte
root.grid_rowconfigure(1, weight=0)     # ligne boutons

# Frame pour l'image (coin haut-gauche)
image_frame = tk.Frame(root, bg='black')
image_frame.grid(row=0, column=0, sticky='nw', padx=10, pady=10)

# Variables globales pour gestion du redimensionnement et cache d'images
image_cache = {}
image_label = None
_current_image_name = None
_last_img_size = None
user_name = ""
script_dir = os.path.dirname(os.path.abspath(__file__))

def _load_image(name: str):
    """Charge une image depuis le dossier images/ ou cr√©e une image de secours si
    le fichier est introuvable. Retourne une PIL.Image."""
    if name in image_cache:
        return image_cache[name]

    if not HAS_PIL:
        return None

    path = os.path.join(script_dir, "images", name)
    try:
        img = Image.open(path).convert("RGBA")
        image_cache[name] = img
        return img
    except Exception:
        # Cr√©e une image de remplacement simple (fond + texte)
        try:
            w = 200
            h = 200
            # Choix de couleur selon le nom (quelques heuristiques)
            if "colere" in name or "enerve" in name:
                color = (180, 30, 30, 255)
            elif "horrible" in name or "screameur" in name:
                color = (40, 10, 40, 255)
            elif "normal" in name:
                color = (30, 90, 30, 255)
            else:
                color = (60, 60, 60, 255)

            img = Image.new("RGBA", (w, h), color)
            try:
                from PIL import ImageDraw, ImageFont
                draw = ImageDraw.Draw(img)
                # Texte court au centre (nom sans extension)
                label = os.path.splitext(name)[0].replace('_', ' ')
                try:
                    font = ImageFont.load_default()
                except Exception:
                    font = None
                tw, th = draw.textsize(label, font=font)
                draw.text(((w - tw) / 2, (h - th) / 2), label, fill=(255,255,255,255), font=font)
            except Exception:
                pass

            image_cache[name] = img
            return img
        except Exception:
            return None

def _compute_target_size():
    """Calcule une taille carr√©e proportionnelle √† la fen√™tre, born√©e min/max."""
    ww = max(1, root.winfo_width())
    wh = max(1, root.winfo_height())
    # 13% de la largeur et 18% de la hauteur, puis on prend le plus petit
    target = int(min(ww * 0.13, wh * 0.18))
    # Bornes de s√©curit√©
    return max(50, min(200, target))

def _resize_image(event=None):
    global _last_img_size
    if not HAS_PIL or not image_label:
        return
    try:
        new_size = _compute_target_size()
        if new_size == _last_img_size:
            return  # √©vite MAJ inutiles

        # R√©cup√®re l'image courante depuis le cache
        img = None
        if _current_image_name:
            img = image_cache.get(_current_image_name) or _load_image(_current_image_name)
        # fallback sur corner_image
        if img is None:
            img = image_cache.get('corner_image.png') or _load_image('corner_image.png')

        if img is None:
            return

        # Compatibilit√© Pillow pour le resampling
        try:
            resample_algo = Image.Resampling.LANCZOS
        except AttributeError:
            resample_algo = getattr(Image, "LANCZOS", getattr(Image, "ANTIALIAS", 0))

        resized = img.resize((new_size, new_size), resample=resample_algo)
        photo = ImageTk.PhotoImage(resized)
        image_label.configure(image=photo)
        image_label.image = photo  # garder r√©f√©rence
        _last_img_size = new_size
        # S'assure que le frame reste au-dessus
        image_frame.lift()
    except Exception as e:
        print(f"Erreur lors du redimensionnement: {e}")

# Chargement et affichage de l'image
if HAS_PIL:
    try:
        # Charge l'image "coin" par d√©faut dans le cache
        _load_image('corner_image.png')

        # Cr√©ation initiale du Label d'image (sera mis √† jour dynamiquement)
        # Utilise une image neutre pour commencer
        init_img = image_cache.get('corner_image.png')
        if init_img is not None:
            try:
                resample_algo = Image.Resampling.LANCZOS
            except AttributeError:
                resample_algo = getattr(Image, "LANCZOS", getattr(Image, "ANTIALIAS", 0))
            initial = init_img.resize((100, 100), resample=resample_algo)
            photo = ImageTk.PhotoImage(initial)
        else:
            photo = None

        image_label = tk.Label(
            image_frame,
            image=photo,
            bg='black',
            bd=0
        )
        if photo is not None:
            image_label.image = photo
        image_label.pack()

        # Lier l'√©v√©nement de redimensionnement et forcer une premi√®re adaptation
        root.bind('<Configure>', _resize_image)
        root.after(0, _resize_image)

    except Exception as e:
        print(f"Erreur de chargement de l'image: {e}")
        placeholder = tk.Label(
            image_frame,
            text="[√ó]",
            bg='black',
            fg='#00ff00',
            font=('Courier', 14)
        )
        placeholder.pack()
else:
    print("PIL non install√© - fonctionnement sans images")

# Zone de texte avec scrollbar (style terminal)
text_scroll = tk.Scrollbar(root, orient='vertical')
text_area = tk.Text(
    root,
    wrap='word',
    padx=20,
    pady=20,
    bg='black',
    fg='#00ff00',
    insertbackground='#00ff00',
    font=('Courier', 12),
    borderwidth=0,
    highlightthickness=0,
)
text_area.configure(yscrollcommand=text_scroll.set)
text_scroll.configure(command=text_area.yview)
text_area.grid(row=0, column=1, sticky='nsew')
text_scroll.grid(row=0, column=2, sticky='ns')

# Frame pour les boutons (en bas, responsive)
btn_frame = tk.Frame(root, bg='black')
btn_frame.grid(row=1, column=1, columnspan=2, sticky='ew', pady=(6, 12), padx=(20, 20))
btn_frame.grid_columnconfigure(0, weight=1)

# Gestion focus/clavier sur les boutons
button_list = []
focus_idx = 0

def focus_button(idx: int):
    global focus_idx
    if not button_list:
        return
    focus_idx = max(0, min(idx, len(button_list) - 1))
    try:
        button_list[focus_idx].focus_set()
    except Exception:
        pass

def on_key_left(event=None):
    if button_list:
        focus_button((focus_idx - 1) % len(button_list))

def on_key_right(event=None):
    if button_list:
        focus_button((focus_idx + 1) % len(button_list))

def on_key_enter(event=None):
    if button_list:
        try:
            button_list[focus_idx].invoke()
        except Exception:
            pass

root.bind('<Left>', on_key_left)
root.bind('<Right>', on_key_right)
root.bind('<Return>', on_key_enter)
root.bind('<KP_Enter>', on_key_enter)
root.bind('<space>', on_key_enter)


def show(node_id):
    global button_list
    node = STORY[node_id]
    # G√©rer l'image associ√©e au n≈ìud (si pr√©sent)
    img_name = node.get("image")
    global _current_image_name, _last_img_size
    if img_name:
        _current_image_name = img_name
        # (re)charger si n√©cessaire
        if HAS_PIL:
            _load_image(img_name)
    else:
        # pas d'image sp√©cifique -> garder l'image par d√©faut
        _current_image_name = 'corner_image.png'

    # Mettre √† jour le texte dans la zone scrollable
    text_area.configure(state='normal')
    text_area.delete('1.0', 'end')
    # Permet d'utiliser {name} dans les textes si user_name est d√©fini
    try:
        formatted = node["text"].format(name=user_name)
    except Exception:
        formatted = node["text"]
    text_area.insert('1.0', formatted)
    text_area.configure(state='disabled')
    text_area.yview_moveto(0)  # remonter en haut

    # Recr√©er les widgets dans btn_frame
    for w in btn_frame.winfo_children():
        w.destroy()
    button_list = []

    # Si le n≈ìud demande une entr√©e (ex: pr√©nom), on ajoute un Entry
    input_key = node.get("input_key")
    entry_var = None
    entry_widget = None
    if input_key:
        entry_var = tk.StringVar()
        entry_widget = tk.Entry(
            btn_frame,
            textvariable=entry_var,
            bg='black',
            fg='#00ff00',
            insertbackground='#00ff00',
            font=('Courier', 11),
            relief='flat',
            borderwidth=1,
            width=30,
        )
        entry_widget.grid(row=0, column=0, columnspan=4, padx=6, pady=(4, 6), sticky='w')

    if node["choices"]:
        for idx, (label, next_id) in enumerate(node["choices"]):
            # Si on a un input_key, le bouton Valider doit r√©cup√©rer la valeur
            if input_key:
                def _on_validate(nid=next_id, var=entry_var):
                    global user_name
                    val = (var.get() if var else "").strip()
                    if not val:
                        root.bell()
                        return
                    user_name = val
                    # afficher un petit retour dans la zone de texte si besoin
                    show(nid)

                cmd = _on_validate
            else:
                cmd = partial(show, next_id)

            btn = tk.Button(
                btn_frame,
                text=f"> {label}",
                command=cmd,
                bg='black',
                fg='#00ff00',
                activebackground='#003300',
                activeforeground='#00ff00',
                font=('Courier', 11),
                relief='flat',
                borderwidth=0,
                cursor='hand2',
                highlightthickness=1,
                highlightbackground='#004400',
                highlightcolor='#00ff00',
                takefocus=True,
                padx=10,
                pady=6,
            )
            # Si on a un entry, placer les boutons sur la ligne suivante
            grid_row = 1 if input_key else 0
            btn.grid(row=grid_row, column=idx, padx=6)
            button_list.append(btn)
        # Focus sur le premier widget (entry si pr√©sent, sinon 1er bouton)
        if entry_widget:
            root.after(0, lambda: entry_widget.focus_set())
        else:
            root.after(0, lambda: focus_button(0))
    else:
        btn = tk.Button(
            btn_frame,
            text="> Quitter",
            command=root.destroy,
            bg='black',
            fg='#00ff00',
            activebackground='#003300',
            activeforeground='#00ff00',
            font=('Courier', 11),
            relief='flat',
            borderwidth=0,
            cursor='hand2',
            highlightthickness=1,
            highlightbackground='#004400',
            highlightcolor='#00ff00',
            takefocus=True,
            padx=10,
            pady=6,
        )
        btn.grid(row=0, column=0, padx=6)
        button_list = [btn]
        root.after(0, lambda: focus_button(0))

# D√©marrer avec la premi√®re sc√®ne
show("start")

# Lancer la boucle principale
# Remonter l'image encore une fois apr√®s la mise en page initiale
root.after(0, image_frame.lift)
root.mainloop()
