#!/usr/bin/env python3

import tkinter as tk
from functools import partial
import os
try:
    from PIL import Image, ImageTk
    HAS_PIL = True
except ImportError:
    HAS_PIL = False

def on_closing():
    text_var.set("> Vous ne pouvez pas quitter comme √ßa...")
    root.bell()  # Fait un son pour l'effet

STORY = {
    "presentation": {
        "text": "Jean-Michel Pointeur (v1.0)
        "Bonjour üòä"
        "Je suis Jean-Michel Pointeur, ton tuteur personnel pour comprendre simplement les pointeurs en C.
        "Ensemble, on va voir ce qu‚Äôest une adresse, comment lire et modifier une valeur via un pointeur, et adopter de bons r√©flexes de s√©curit√©. Youpi !"

        "Prends ton temps, r√©ponds √† ton rythme : je t‚Äôexplique tout pas √† pas."

    #PLACEHOLDER : Bouton ENTER
    "Appuie sur ENTER pour commencer."
    },

    "Enter your name": {
        "text": "Bienvenue dans cette aventure interactive !
        "Comment t'appelles-tu ?",

    #PLACEHOLDER : Champ de texte pour le nom
    "Entrez votre nom :", 
    #PLACEHOLDER : Bouton SUBMIT
    "Valider"
    },

    "first question": {
        "Text": L'adresse de variable, operateur&   
        Une variable en C a une adresse en m√©moire. Pour obtenir cette adresse, on utilise l'op√©rateur &.
        Selon toi que represente &n ?", 

    #PLACEHOLDER : BOUTON REPONSE 1
    "L'adresse de la variable n",
    #PLACEHOLDER : BOUTON REPONSE 2 fausse
    "La valeur de la variable n",
    },

    "second question": {
        "text": "D√©r√©ferencer un pointeur, c'est acc√©der √† la valeur stock√©e √† l'adresse point√©e. On utilise l'op√©rateur * pour cela.
        Que fait l'expression *p si p est un pointeur vers un entier ?",

    #PLACEHOLDER : BOUTON REPONSE 1
    "Acc√®de √† la valeur enti√®re point√©e par p",
    #PLACEHOLDER : BOUTON REPONSE 2 fausse
    "Acc√®de √† l'adresse de p",  
    },

    "third question": {
        "text": "Q3 ‚Äî Comprendre l‚Äôenvers."
        "Que fait l‚Äôexpression &*p si p est un pointeur valide ?",
    
    #PLACEHOLDER : BOUTON REPONSE 1 (CELLE QUI DECLENCHE L'ERREUR)
        "Retourne la valeur stock√©e √† l'adresse de p",
    #PLACEHOLDER : BOUTON REPONSE 1
        "Retourne l'adresse point√©e par p",
    },

    " CAS D'ERREUR": {
        "Oups ! Non, il semble que tu te sois tromp√©. Reprenons ensemble pour bien comprendre."
    #PLACEHOLDER : REMETTRE LA QUESTION PRECEDENTE
    #PUIS REPRODUIRE L'ERREUR. LA QUESTION NE PEUT PAS ETRE VALIDEE.

    "Jean-Michel s'enerve": {
        "text": "Jean-Michel Pointeur (v1.1)
        √áa suffit les erreurs ! On va tout reprendre depuis le d√©but.
        Cette fois, tu vas √©couter attentivement et suivre mes instructions √† la lettre. Pas de place pour l'erreur cette fois-ci !
},

    "4)Strange question": {
        "Si tu ne pouvais sauver qu'une personne, tu choisirais de sauver :",
    #PLACEHOLDER : BOUTON REPONSE 1
        "Un(e) ami(e)",
    #PLACEHOLDER : BOUTON REPONSE 2
        "Un(e) membre de ta famille",
    }

root = tk.Tk()
root.title("Terminal")
root.geometry("600x400")
root.configure(bg='black')
root.protocol("WM_DELETE_WINDOW", on_closing)  # Intercepte la croix

# Frame pour l'image dans le coin
image_frame = tk.Frame(root, bg='black')
image_frame.place(x=10, y=10)  # Position fixe dans le coin

# Chargement et affichage de l'image
if HAS_PIL:
    try:
        # Chemin absolu de l'image (dans le dossier images √† c√¥t√© du script)
        script_dir = os.path.dirname(os.path.abspath(__file__))
        image_path = os.path.join(script_dir, "images", "corner_image.png")

        # Charger l'image
        image = Image.open(image_path)

        # Choisir l'algorithme de redimensionnement compatible selon la version de Pillow
        try:
            resample_algo = Image.Resampling.LANCZOS  # Pillow >= 9.1
        except AttributeError:
            # Fallback pour anciennes versions de Pillow
            resample_algo = getattr(Image, "LANCZOS", getattr(Image, "ANTIALIAS", 0))

        # Redimensionner l'image (ajustez la taille selon vos besoins)
        image = image.resize((80, 80), resample=resample_algo)
        photo = ImageTk.PhotoImage(image)

        # Cr√©er le label avec l'image
        image_label = tk.Label(
            image_frame,
            image=photo,
            bg='black',
            bd=0  # Pas de bordure
        )
        # Conserver une r√©f√©rence pour √©viter le garbage collection
        image_label.image = photo
        image_label.pack()

    except Exception as e:
        print(f"Erreur de chargement de l'image: {e}")
        print(f"Chemin test√©: {locals().get('image_path', 'inconnu')}")
        # Placeholder en cas d'erreur
        placeholder = tk.Label(
            image_frame,
            text="[√ó]",  # Symbole simple
            bg='black',
            fg='#00ff00',
            font=('Courier', 14)
        )
        placeholder.pack()
else:
    print("PIL non install√© - fonctionnement sans images")

# Style terminal (texte)
text_var = tk.StringVar()
text_label = tk.Label(
    root, 
    textvariable=text_var, 
    wraplength=540,
    justify="left",
    padx=20,
    pady=20,
    bg='black',
    fg='#00ff00',
    font=('Courier', 12)
)
text_label.pack(fill="both", expand=True)
# S'assurer que l'image reste au-dessus du texte
image_frame.lift()

# Frame pour les boutons
btn_frame = tk.Frame(root, bg='black')
btn_frame.pack(pady=8)

def show(node_id):
    node = STORY[node_id]
    text_var.set(node["text"])
    for w in btn_frame.winfo_children():
        w.destroy()
    if node["choices"]:
        for label, next_id in node["choices"]:
            btn = tk.Button(
                btn_frame,
                text=f"> {label}",
                width=30,
                command=partial(show, next_id),
                bg='black',
                fg='#00ff00',
                activebackground='#003300',
                activeforeground='#00ff00',
                font=('Courier', 10),
                relief='flat',
                borderwidth=0,
                cursor='hand2'
            )
            btn.pack(pady=2)
    else:
        tk.Button(
            btn_frame,
            text="> Quitter",
            width=30,
            command=root.destroy,
            bg='black',
            fg='#00ff00',
            activebackground='#003300',
            activeforeground='#00ff00',
            font=('Courier', 10),
            relief='flat',
            borderwidth=0,
            cursor='hand2'
        ).pack(pady=4)

# D√©marrer avec la premi√®re sc√®ne
show("start")

# Lancer la boucle principale
# Remonter l'image encore une fois apr√®s la mise en page initiale
root.after(0, image_frame.lift)
root.mainloop()