#!/usr/bin/env python3

import tkinter as tk
from functools import partial
import os
try:
    from PIL import Image, ImageTk
    HAS_PIL = True
except ImportError:
    HAS_PIL = False

def on_closing():
    # AFFICHE VISAGE MECONTENT
    text_var.set("> Vous ne pouvez pas quitter comme √ßa...")
    root.bell()  # Fait un son pour l'effet

STORY = {
    "start": {
        "text": """Jean-Michel Pointeur (v1.0)
Bonjour üòä
Je suis Jean-Michel Pointeur, ton tuteur personnel pour comprendre simplement les pointeurs en C.
Ensemble, on va voir ce qu'est une adresse, comment lire et modifier une valeur via un pointeur, et adopter de bons r√©flexes de s√©curit√©. Youpi !

Prends ton temps, r√©ponds √† ton rythme : je t'explique tout pas √† pas.

Appuie sur ENTER pour commencer.""",
        "choices": [("Commencer", "enter_name")]
    },

    "enter_name": {
        "text": """Bienvenue dans cette aventure interactive !
Comment t'appelles-tu ?

Entrez votre nom :""",
        "choices": [("Valider", "first_question")]
    },

    "first_question": {
        "text": """L'adresse de variable, operateur&   
Une variable en C a une adresse en m√©moire. Pour obtenir cette adresse, on utilise l'op√©rateur &.
Selon toi que represente &n ?""",
        "choices": [
            ("L'adresse de la variable n", "second_question"),
            ("La valeur de la variable n", "cas_erreur")
        ]
    },

    "second_question": {
        "text": """D√©r√©ferencer un pointeur, c'est acc√©der √† la valeur stock√©e √† l'adresse point√©e. On utilise l'op√©rateur * pour cela.
Que fait l'expression *p si p est un pointeur vers un entier ?""",
        "choices": [
            ("Acc√®de √† la valeur enti√®re point√©e par p", "third_question"),
            ("Acc√®de √† l'adresse de p", "cas_erreur")
        ]
    },

    "third_question": {
        "text": """Q3 ‚Äî Comprendre l'envers.
Que fait l'expression &*p si p est un pointeur valide ?""",
        "choices": [
            ("Retourne la valeur stock√©e √† l'adresse de p", "jean_michel_enerve"),
            ("Retourne l'adresse point√©e par p", "strange_question")
        ]
    },
#PLACEHOLDER VISAGE MECONTENT
    "cas_erreur": {
        "text": """Oups ! Non, il semble que tu te sois tromp√©. Reprenons ensemble pour bien comprendre.""",
        "choices": [("Recommencer", "first_question")]
    },

#PLACEHOLDER VISAGE EN COLERE
    "jean_michel_enerve": {
        "text": """Jean-Michel Pointeur (v1.1)
√áa suffit les erreurs ! On va tout reprendre depuis le d√©but.
Cette fois, tu vas √©couter attentivement et suivre mes instructions √† la lettre. Pas de place pour l'erreur cette fois-ci !""",
        "choices": [("Recommencer", "third_question")]
    },
#PLACEHOLDER VISAGE NORMAL
    "strange_question": {
        "text": """Si tu ne pouvais sauver qu'une personne, tu choisirais de sauver :""",
        "choices": [
            ("Un(e) ami(e)", "end"),
            ("Un(e) membre de ta famille", "end")
        ]
    },

    "end": {
        "text": """Est-ce-que-tu-pr√©f√®res :""",
        "choices": [
            ("Me rejoindre?", "end"),
            ("Ou que je vienne te chercher :)?", "end")
        ]
#PLACEHOLDER VISAGE HORRIBLE (SCREAMEUR)
        }
    }

root = tk.Tk()
root.title("Terminal")
root.geometry("960x600")
root.configure(bg='black')
root.protocol("WM_DELETE_WINDOW", on_closing)  # Intercepte la croix

# Layout principal en grille (responsive)
root.grid_columnconfigure(0, weight=0)  # colonne image
root.grid_columnconfigure(1, weight=1)  # colonne texte/boutons
root.grid_rowconfigure(0, weight=1)     # ligne texte
root.grid_rowconfigure(1, weight=0)     # ligne boutons

# Frame pour l'image (coin haut-gauche)
image_frame = tk.Frame(root, bg='black')
image_frame.grid(row=0, column=0, sticky='nw', padx=10, pady=10)

# Variables globales pour gestion du redimensionnement
original_image = None
image_label = None
_last_img_size = None

def _compute_target_size():
    """Calcule une taille carr√©e proportionnelle √† la fen√™tre, born√©e min/max."""
    ww = max(1, root.winfo_width())
    wh = max(1, root.winfo_height())
    # 13% de la largeur et 18% de la hauteur, puis on prend le plus petit
    target = int(min(ww * 0.13, wh * 0.18))
    # Bornes de s√©curit√©
    return max(50, min(200, target))

def _resize_image(event=None):
    global _last_img_size
    if not (HAS_PIL and original_image and image_label):
        return
    try:
        new_size = _compute_target_size()
        if new_size == _last_img_size:
            return  # √©vite MAJ inutiles

        # Compatibilit√© Pillow pour le resampling
        try:
            resample_algo = Image.Resampling.LANCZOS
        except AttributeError:
            resample_algo = getattr(Image, "LANCZOS", getattr(Image, "ANTIALIAS", 0))

        resized = original_image.resize((new_size, new_size), resample=resample_algo)
        photo = ImageTk.PhotoImage(resized)
        image_label.configure(image=photo)
        image_label.image = photo  # garder r√©f√©rence
        _last_img_size = new_size
        # S'assure que le frame reste au-dessus
        image_frame.lift()
    except Exception as e:
        print(f"Erreur lors du redimensionnement: {e}")

# Chargement et affichage de l'image
if HAS_PIL:
    try:
        # Chemin absolu de l'image (dans le dossier images √† c√¥t√© du script)
        script_dir = os.path.dirname(os.path.abspath(__file__))
        image_path = os.path.join(script_dir, "images", "corner_image.png")

        # Charger l'image originale
        original_image = Image.open(image_path)

        # Cr√©ation initiale avec une taille par d√©faut (sera ajust√©e ensuite)
        try:
            resample_algo = Image.Resampling.LANCZOS
        except AttributeError:
            resample_algo = getattr(Image, "LANCZOS", getattr(Image, "ANTIALIAS", 0))
        initial = original_image.resize((100, 100), resample=resample_algo)
        photo = ImageTk.PhotoImage(initial)

        image_label = tk.Label(
            image_frame,
            image=photo,
            bg='black',
            bd=0
        )
        image_label.image = photo
        image_label.pack()

        # Lier l'√©v√©nement de redimensionnement et forcer une premi√®re adaptation
        root.bind('<Configure>', _resize_image)
        root.after(0, _resize_image)

    except Exception as e:
        print(f"Erreur de chargement de l'image: {e}")
        print(f"Chemin test√©: {locals().get('image_path', 'inconnu')}")
        placeholder = tk.Label(
            image_frame,
            text="[√ó]",
            bg='black',
            fg='#00ff00',
            font=('Courier', 14)
        )
        placeholder.pack()
else:
    print("PIL non install√© - fonctionnement sans images")

# Zone de texte avec scrollbar (style terminal)
text_scroll = tk.Scrollbar(root, orient='vertical')
text_area = tk.Text(
    root,
    wrap='word',
    padx=20,
    pady=20,
    bg='black',
    fg='#00ff00',
    insertbackground='#00ff00',
    font=('Courier', 12),
    borderwidth=0,
    highlightthickness=0,
)
text_area.configure(yscrollcommand=text_scroll.set)
text_scroll.configure(command=text_area.yview)
text_area.grid(row=0, column=1, sticky='nsew')
text_scroll.grid(row=0, column=2, sticky='ns')

# Frame pour les boutons (en bas, responsive)
btn_frame = tk.Frame(root, bg='black')
btn_frame.grid(row=1, column=1, columnspan=2, sticky='ew', pady=(6, 12), padx=(20, 20))
btn_frame.grid_columnconfigure(0, weight=1)

# Gestion focus/clavier sur les boutons
button_list = []
focus_idx = 0

def focus_button(idx: int):
    global focus_idx
    if not button_list:
        return
    focus_idx = max(0, min(idx, len(button_list) - 1))
    try:
        button_list[focus_idx].focus_set()
    except Exception:
        pass

def on_key_left(event=None):
    if button_list:
        focus_button((focus_idx - 1) % len(button_list))

def on_key_right(event=None):
    if button_list:
        focus_button((focus_idx + 1) % len(button_list))

def on_key_enter(event=None):
    if button_list:
        try:
            button_list[focus_idx].invoke()
        except Exception:
            pass

root.bind('<Left>', on_key_left)
root.bind('<Right>', on_key_right)
root.bind('<Return>', on_key_enter)
root.bind('<KP_Enter>', on_key_enter)
root.bind('<space>', on_key_enter)

def show(node_id):
    global button_list
    node = STORY[node_id]

    # Mettre √† jour le texte dans la zone scrollable
    text_area.configure(state='normal')
    text_area.delete('1.0', 'end')
    text_area.insert('1.0', node["text"])
    text_area.configure(state='disabled')
    text_area.yview_moveto(0)  # remonter en haut

    # Recr√©er les boutons
    for w in btn_frame.winfo_children():
        w.destroy()
    button_list = []

    if node["choices"]:
        for idx, (label, next_id) in enumerate(node["choices"]):
            btn = tk.Button(
                btn_frame,
                text=f"> {label}",
                command=partial(show, next_id),
                bg='black',
                fg='#00ff00',
                activebackground='#003300',
                activeforeground='#00ff00',
                font=('Courier', 11),
                relief='flat',
                borderwidth=0,
                cursor='hand2',
                highlightthickness=1,
                highlightbackground='#004400',
                highlightcolor='#00ff00',
                takefocus=True,
                padx=10,
                pady=6,
            )
            btn.grid(row=0, column=idx, padx=6)
            button_list.append(btn)
        # Focus sur le premier bouton
        root.after(0, lambda: focus_button(0))
    else:
        btn = tk.Button(
            btn_frame,
            text="> Quitter",
            command=root.destroy,
            bg='black',
            fg='#00ff00',
            activebackground='#003300',
            activeforeground='#00ff00',
            font=('Courier', 11),
            relief='flat',
            borderwidth=0,
            cursor='hand2',
            highlightthickness=1,
            highlightbackground='#004400',
            highlightcolor='#00ff00',
            takefocus=True,
            padx=10,
            pady=6,
        )
        btn.grid(row=0, column=0, padx=6)
        button_list = [btn]
        root.after(0, lambda: focus_button(0))

# D√©marrer avec la premi√®re sc√®ne
show("start")

# Lancer la boucle principale
# Remonter l'image encore une fois apr√®s la mise en page initiale
root.after(0, image_frame.lift)
root.mainloop()
