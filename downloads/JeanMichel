#!/usr/bin/env python3

import tkinter as tk
from functools import partial
import os
import webbrowser
import subprocess
import shutil
import threading
import socket
import http.server
import socketserver
import mimetypes

try:
    from PIL import Image, ImageTk
    HAS_PIL = True
except ImportError:
    HAS_PIL = False

# === CONSTANTES ===
TERMINAL_BG = 'black'
TERMINAL_FG = '#00ff00'
TERMINAL_ACTIVE_BG = '#003300'
TERMINAL_HIGHLIGHT_BG = '#004400'
TERMINAL_FONT = ('Courier', 11)
TERMINAL_FONT_LARGE = ('Courier', 12)
IMAGE_SIZE_RATIO = (0.20, 0.30)  # (largeur%, hauteur%)
IMAGE_SIZE_BOUNDS = (80, 350)    # (min, max)
SERVER_PORT = 8000

def on_closing():
    """Affiche un message puis d√©clenche un screamer avant de fermer."""
    global _closing_overlay_shown
    if not '_closing_overlay_shown' in globals():
        _closing_overlay_shown = False
    if not _closing_overlay_shown:
        _closing_overlay_shown = True
        try:
            text_area.configure(state='normal')
            text_area.delete('1.0', 'end')
            text_area.insert('1.0', "> Vous ne pouvez pas quitter comme √ßa...")
            text_area.configure(state='disabled')
        except Exception:
            pass
        root.bell()  # Fait un son pour l'effet
        # Screamer puis fermeture
        try:
            _show_screamer_overlay(on_done=root.destroy)
        except Exception:
            root.after(200, root.destroy)
    else:
        # D√©j√† en cours, ignorer
        pass

def _show_screamer_overlay(on_done=None):
    """Affiche l'image screamer en overlay plein √©cran pendant 2s.
    Si on_done est None, ouvre l'endcard √† la fin, sinon ex√©cute on_done.
    """
    if on_done is None:
        on_done = _open_html_endcard
    if not HAS_PIL:
        on_done()
        return

    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        img_path = os.path.join(script_dir, 'images', 'screamer_terminal.png')
        if not os.path.exists(img_path):
            on_done()
            return

        # Fen√™tre overlay au-dessus de tout, bordures masqu√©es
        overlay = tk.Toplevel(root)
        overlay.attributes('-topmost', True)
        overlay.overrideredirect(True)
        overlay.configure(bg='black')
        try:
            overlay.lift()
            overlay.focus_force()
        except Exception:
            pass

        # Plein √©cran fiable
        overlay.update_idletasks()
        try:
            overlay.attributes('-fullscreen', True)
        except Exception:
            pass
        sw = overlay.winfo_screenwidth()
        sh = overlay.winfo_screenheight()
        overlay.geometry(f"{sw}x{sh}+0+0")

        # Charger et adapter l'image (80% hauteur √©cran)
        img = Image.open(img_path)
        target_h = int(sh * 0.8)
        ratio = img.size[0] / img.size[1]
        target_w = int(target_h * ratio)
        img = img.resize((target_w, target_h), Image.LANCZOS)
        photo = ImageTk.PhotoImage(img)

        lbl = tk.Label(overlay, image=photo, bg='black')
        lbl.image = photo  # emp√™cher le GC
        lbl.place(relx=0.5, rely=0.5, anchor='center')

        def _close_then_open():
            try:
                overlay.destroy()
            except Exception:
                pass
            on_done()

        overlay.after(2000, _close_then_open)
    except Exception as e:
        try:
            print(f"Erreur screamer overlay: {e}")
        except Exception:
            pass
        on_done()

def _show_screamer_overlay():
    """Affiche le screamer anim√© (GIF) + audio en overlay avant la fin."""
    if not HAS_PIL:
        _open_html_endcard()
        return
    
    script_dir = os.path.dirname(os.path.abspath(__file__))
    gif_path = os.path.join(script_dir, 'images', 'screamer_animated_transparent.gif')
    audio_path = os.path.join(script_dir, 'images', 'screamer_audio.mp3')
    
    if not os.path.exists(gif_path):
        # Fallback sur image fixe
        img_path = os.path.join(script_dir, 'images', 'screamer_terminal.png')
        if os.path.exists(img_path):
            _show_screamer_static(img_path)
        else:
            _open_html_endcard()
        return
    
    # Cr√©er fen√™tre overlay plein √©cran NOIRE (pr√©chargement)
    overlay = tk.Toplevel()
    overlay.attributes('-topmost', True)
    overlay.configure(bg='black')
    overlay.overrideredirect(True)
    
    screen_w = overlay.winfo_screenwidth()
    screen_h = overlay.winfo_screenheight()
    overlay.geometry(f"{screen_w}x{screen_h}+0+0")
    
    # Label noir vide pendant le chargement
    label = tk.Label(overlay, bg='black')
    label.place(relx=0.5, rely=0.5, anchor='center')
    
    # Forcer l'affichage imm√©diat de l'√©cran noir
    overlay.update()
    
    try:
        # PR√âCHARGER le GIF et les frames AVANT de jouer l'audio
        gif = Image.open(gif_path)
        target_h = int(screen_h * 0.8)
        
        # Extraire et redimensionner toutes les frames
        frames = []
        try:
            while True:
                frame = gif.copy().convert('RGBA')
                ratio = frame.size[0] / frame.size[1]
                target_w = int(target_h * ratio)
                frame_resized = frame.resize((target_w, target_h), Image.LANCZOS)
                frames.append(ImageTk.PhotoImage(frame_resized))
                gif.seek(gif.tell() + 1)
        except EOFError:
            pass
        
        if not frames:
            raise Exception("No frames in GIF")
        
        # MAINTENANT que tout est charg√©, initialiser l'audio (sans jouer)
        audio_ready = False
        try:
            import pygame
            pygame.mixer.init()
            if os.path.exists(audio_path):
                pygame.mixer.music.load(audio_path)
                audio_ready = True
        except Exception as e:
            print(f"Audio error: {e}")
        
        # Variables d'animation
        frame_idx = [0]
        animation_active = [True]
        
        def animate():
            if animation_active[0] and frames:
                label.config(image=frames[frame_idx[0]])
                frame_idx[0] = (frame_idx[0] + 1) % len(frames)
                overlay.after(66, animate)  # ~15fps
        
        def stop_and_continue():
            animation_active[0] = False
            if audio_ready:
                try:
                    pygame.mixer.music.stop()
                except Exception:
                    pass
            overlay.destroy()
            _open_html_endcard()
        
        # Fonction pour d√©marrer l'audio ET l'animation en m√™me temps
        def start_screamer():
            if audio_ready:
                try:
                    pygame.mixer.music.play()
                except Exception:
                    pass
            animate()
            # Fermer apr√®s dur√©e de la vid√©o (~7 secondes)
            overlay.after(7000, stop_and_continue)
        
        # Attendre 100ms (√©cran noir visible) puis d√©marrer TOUT synchronis√©
        overlay.after(100, start_screamer)
        
    except Exception as e:
        print(f"Erreur screamer anim√©: {e}")
        overlay.destroy()
        _open_html_endcard()

def _show_screamer_static(img_path):
    """Fallback: affiche l'image fixe si le GIF n'est pas dispo."""
    overlay = tk.Toplevel()
    overlay.attributes('-topmost', True)
    overlay.configure(bg='black')
    overlay.overrideredirect(True)
    
    screen_w = overlay.winfo_screenwidth()
    screen_h = overlay.winfo_screenheight()
    overlay.geometry(f"{screen_w}x{screen_h}+0+0")
    
    try:
        img = Image.open(img_path)
        target_h = int(screen_h * 0.8)
        ratio = img.size[0] / img.size[1]
        target_w = int(target_h * ratio)
        img_resized = img.resize((target_w, target_h), Image.LANCZOS)
        photo = ImageTk.PhotoImage(img_resized)
        
        label = tk.Label(overlay, image=photo, bg='black')
        label.image = photo
        label.place(relx=0.5, rely=0.5, anchor='center')
        
        overlay.after(2000, lambda: (overlay.destroy(), _open_html_endcard()))
    except Exception as e:
        print(f"Erreur image fixe: {e}")
        overlay.destroy()
        _open_html_endcard()

def _open_html_endcard():
    """Ouvre game/index.html via un serveur HTTP local."""
    def _port_in_use(port):
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(0.25)
            return s.connect_ex(("127.0.0.1", port)) == 0

    def _start_server(game_dir):
        try:
            from functools import partial as _partial
            Handler = _partial(http.server.SimpleHTTPRequestHandler, directory=game_dir)
        except TypeError:
            cwd = os.getcwd()
            os.chdir(game_dir)
            Handler = http.server.SimpleHTTPRequestHandler
        
        class ReusableTCPServer(socketserver.TCPServer):
            allow_reuse_address = True
        
        httpd = ReusableTCPServer(("", SERVER_PORT), Handler)
        threading.Thread(target=httpd.serve_forever, daemon=True).start()
    
    def _wait_for_server(port, timeout=3):
        """Attendre que le serveur soit pr√™t."""
        import time
        start = time.time()
        while time.time() - start < timeout:
            if _port_in_use(port):
                return True
            time.sleep(0.1)
        return False

    script_dir = os.path.dirname(os.path.abspath(__file__))
    game_dir = os.path.join(script_dir, 'game')
    
    if not os.path.exists(os.path.join(game_dir, 'index.html')):
        print("Erreur: 'game/index.html' introuvable.")
        return
    
    mimetypes.add_type('application/wasm', '.wasm')
    mimetypes.add_type('application/javascript', '.js')
    mimetypes.add_type('text/css', '.css')
    
    # D√©marrer le serveur si n√©cessaire
    if not _port_in_use(SERVER_PORT):
        try:
            _start_server(game_dir)
            # Attendre que le serveur soit pr√™t
            if not _wait_for_server(SERVER_PORT):
                print("Avertissement: Le serveur HTTP met du temps √† d√©marrer")
        except Exception as e:
            print(f"Erreur serveur HTTP: {e}")
            return
    
    url = f"http://127.0.0.1:{SERVER_PORT}/index.html"
    
    # Tentative d'ouverture selon l'environnement
    # 1. WSL/Linux outils
    for cmd in ['wslview', 'xdg-open']:
        if shutil.which(cmd):
            try:
                subprocess.Popen([cmd, url], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                root.after(200, root.destroy)
                return
            except Exception:
                pass
    
    # 2. Python webbrowser (fonctionne sur Windows, Mac, Linux)
    try:
        webbrowser.open(url, new=2)  # new=2 = nouvel onglet si possible
        root.after(200, root.destroy)
    except Exception as e:
        print(f"Impossible d'ouvrir le navigateur: {e}")
        print(f"Ouvrez manuellement: {url}")

STORY = {
    "start": {
        "text": """Jean-Michel Pointeur (v1.0)
Bonjour üòä
Je suis Jean-Michel Pointeur, ton tuteur personnel pour comprendre simplement les pointeurs en C.
Ensemble, on va voir ce qu'est une adresse, comment lire et modifier une valeur via un pointeur, et adopter de bons r√©flexes de s√©curit√©. Youpi !

Prends ton temps, r√©ponds √† ton rythme : je t'explique tout pas √† pas.

Appuie sur ENTER pour commencer.""",
        "choices": [("Commencer", "enter_name")],
        "image": "normal.png"
    },

    "enter_name": {
        "text": """Bienvenue dans cette aventure interactive !
Comment t'appelles-tu ?

Entrez votre nom :""",
        "choices": [("Valider", "first_question")],
        "image": "normal.png",
        "input_key": "name"
    },

    "first_question": {
        "text": """L'adresse de variable, operateur&   
Une variable en C a une adresse en m√©moire. Pour obtenir cette adresse, on utilise l'op√©rateur &.
Selon toi que represente &n ?""",
        "choices": [
            ("L'adresse de la variable n", "second_question"),
            ("La valeur de la variable n", "cas_erreur_q1")
        ]
        ,"image": "normal.png"
    },

    "second_question": {
        "text": """D√©r√©ferencer un pointeur, c'est acc√©der √† la valeur stock√©e √† l'adresse point√©e. On utilise l'op√©rateur * pour cela.
Que fait l'expression *p si p est un pointeur vers un entier ?""",
        "choices": [
            ("Acc√®de √† la valeur enti√®re point√©e par p", "third_question"),
            ("Acc√®de √† l'adresse de p", "cas_erreur_q2")
        ]
        ,"image": "normal.png"
    },

    "third_question": {
        "text": """Q3 ‚Äî Comprendre l'envers.
Que fait l'expression &*p si p est un pointeur valide ?""",
        "choices": [
            ("Retourne la valeur stock√©e √† l'adresse de p", "cas_erreur_q3"),
            ("Retourne l'adresse point√©e par p", "strange_question")
        ]
        ,"image": "normal.png"
    },
    "cas_erreur_q1": {
        "text": """Oups ! Non, il semble que tu te sois tromp√©. Reprenons ensemble pour bien comprendre.""",
        "choices": [("Recommencer", "first_question")],
        "image": "mecontent.png"
    },
    "cas_erreur_q2": {
        "text": """Oups ! Non, il semble que tu te sois tromp√©. Reprenons ensemble pour bien comprendre.""",
        "choices": [("Recommencer", "second_question")],
        "image": "mecontent.png"
    },
    "cas_erreur_q3": {
        "text": """Oups ! Non, il semble que tu te sois tromp√©. Reprenons ensemble pour bien comprendre.""",
        "choices": [("Recommencer", "third_question")],
        "image": "mecontent.png"
    },
    "jean_michel_enerve": {
        "text": """Jean-Michel Pointeur (v1.1)
√áa suffit les erreurs ! On va tout reprendre depuis le d√©but.
Cette fois, tu vas √©couter attentivement et suivre mes instructions √† la lettre. Pas de place pour l'erreur cette fois-ci !""",
        "choices": [("Recommencer", "third_question")],
        "image": "colere.png"
    },
    "strange_question": {
        "text": """Si tu ne pouvais sauver qu'une personne, tu choisirais de sauver :""",
        "choices": [
            ("Un(e) ami(e)", "end"),
            ("Un(e) membre de ta famille", "end")
        ]
        ,"image": "big_mouth.png"
    },

    "end": {
        "text": """Est-ce-que-tu-pr√©f√®res :""",
        "choices": [
            ("Me rejoindre?", "end"),
            ("Ou que je vienne te chercher :)?", "end")
        ]
        ,"image": "screamer.png"
    }
    }

root = tk.Tk()
root.title("Terminal")
root.geometry("960x600")
root.configure(bg='black')
root.protocol("WM_DELETE_WINDOW", on_closing)  # Intercepte la croix

# Layout principal en grille (responsive)
root.grid_columnconfigure(0, weight=0)  # colonne image
root.grid_columnconfigure(1, weight=1)  # colonne texte/boutons
root.grid_rowconfigure(0, weight=1)     # ligne texte
root.grid_rowconfigure(1, weight=0)     # ligne boutons

# Frame pour l'image (coin haut-gauche)
image_frame = tk.Frame(root, bg='black')
image_frame.grid(row=0, column=0, sticky='nw', padx=10, pady=10)


# Gestion image dynamique et cache
image_cache = {}
image_label = None
_current_image_name = None
_last_img_size = None
user_name = ""
has_previous_errors = False  # Pour traquer les erreurs aux questions 1 et 2
script_dir = os.path.dirname(os.path.abspath(__file__))

def _load_image(name: str):
    """Charge une image depuis le dossier images/ ou cr√©e une image de secours si
    le fichier est introuvable. Retourne une PIL.Image."""
    if name in image_cache:
        return image_cache[name]
    if not HAS_PIL:
        return None
    path = os.path.join(script_dir, "images", name)
    try:
        img = Image.open(path).convert("RGBA")
        image_cache[name] = img
        return img
    except Exception:
        # Cr√©e une image de remplacement simple (fond + texte)
        try:
            w = 200
            h = 200
            if "colere" in name or "enerve" in name:
                color = (180, 30, 30, 255)
            elif "horrible" in name or "screameur" in name:
                color = (40, 10, 40, 255)
            elif "normal" in name:
                color = (30, 90, 30, 255)
            else:
                color = (60, 60, 60, 255)
            img = Image.new("RGBA", (w, h), color)
            try:
                from PIL import ImageDraw, ImageFont
                draw = ImageDraw.Draw(img)
                label = os.path.splitext(name)[0].replace('_', ' ')
                try:
                    font = ImageFont.load_default()
                except Exception:
                    font = None
                tw, th = draw.textsize(label, font=font)
                draw.text(((w - tw) / 2, (h - th) / 2), label, fill=(255,255,255,255), font=font)
            except Exception:
                pass
            image_cache[name] = img
            return img
        except Exception:
            return None

def _compute_target_size():
    """Calcule une taille proportionnelle √† la fen√™tre, born√©e min/max."""
    ww, wh = max(1, root.winfo_width()), max(1, root.winfo_height())
    target = int(min(ww * IMAGE_SIZE_RATIO[0], wh * IMAGE_SIZE_RATIO[1]))
    return max(IMAGE_SIZE_BOUNDS[0], min(IMAGE_SIZE_BOUNDS[1], target))

def _resize_image(event=None):
    """Redimensionne l'image en gardant le ratio d'aspect."""
    global _last_img_size
    if not (HAS_PIL and image_label):
        return
    
    target_height = _compute_target_size()
    if target_height == _last_img_size:
        return
    
    # R√©cup√©rer l'image depuis le cache
    img = (_current_image_name and (image_cache.get(_current_image_name) or _load_image(_current_image_name))) \
          or image_cache.get('normal.png') or _load_image('normal.png')
    if not img:
        return
    
    # Redimensionner en gardant le ratio
    aspect_ratio = img.size[0] / img.size[1]
    new_size = (int(target_height * aspect_ratio), target_height)
    
    try:
        resample = Image.Resampling.LANCZOS
    except AttributeError:
        resample = getattr(Image, "LANCZOS", getattr(Image, "ANTIALIAS", 0))
    
    try:
        resized = img.resize(new_size, resample=resample)
        photo = ImageTk.PhotoImage(resized)
        image_label.configure(image=photo)
        image_label.image = photo
        _last_img_size = target_height
        image_frame.lift()
    except Exception as e:
        print(f"Erreur redimensionnement: {e}")

# Chargement et affichage de l'image
if HAS_PIL:
    try:
        _load_image('normal.png')
        init_img = image_cache.get('normal.png')
        if init_img is not None:
            try:
                resample_algo = Image.Resampling.LANCZOS
            except AttributeError:
                resample_algo = getattr(Image, "LANCZOS", getattr(Image, "ANTIALIAS", 0))
            initial = init_img.resize((100, 100), resample=resample_algo)
            photo = ImageTk.PhotoImage(initial)
        else:
            photo = None
        image_label = tk.Label(
            image_frame,
            image=photo,
            bg='black',
            bd=0
        )
        image_label.image = photo
        image_label.pack()
        root.bind('<Configure>', _resize_image)
        root.after(0, _resize_image)
    except Exception as e:
        print(f"Erreur de chargement de l'image: {e}")
        print(f"Chemin test√©: {locals().get('image_path', 'inconnu')}" )
        placeholder = tk.Label(
            image_frame,
            text="[√ó]",
            bg='black',
            fg='#00ff00',
            font=('Courier', 14)
        )
        placeholder.pack()
else:
    print("PIL non install√© - fonctionnement sans images")

# Zone de texte avec scrollbar (style terminal)
text_scroll = tk.Scrollbar(root, orient='vertical')
text_area = tk.Text(
    root, wrap='word', padx=20, pady=20,
    bg=TERMINAL_BG, fg=TERMINAL_FG, insertbackground=TERMINAL_FG,
    font=TERMINAL_FONT_LARGE, borderwidth=0, highlightthickness=0
)
text_area.configure(yscrollcommand=text_scroll.set)
text_scroll.configure(command=text_area.yview)
text_area.grid(row=0, column=1, sticky='nsew')
text_scroll.grid(row=0, column=2, sticky='ns')

# Frame pour les boutons (en bas, responsive)
btn_frame = tk.Frame(root, bg=TERMINAL_BG)
btn_frame.grid(row=1, column=1, columnspan=2, sticky='ew', pady=(6, 12), padx=(20, 20))
btn_frame.grid_columnconfigure(0, weight=1)

# Gestion focus/clavier sur les boutons
button_list = []
focus_idx = 0
_end_html_opened = False

def _create_button(parent, text, command):
    """Cr√©e un bouton avec le style terminal unifi√©."""
    return tk.Button(
        parent, text=text, command=command,
        bg=TERMINAL_BG, fg=TERMINAL_FG,
        activebackground=TERMINAL_ACTIVE_BG, activeforeground=TERMINAL_FG,
        font=TERMINAL_FONT, relief='flat', borderwidth=0, cursor='hand2',
        highlightthickness=1, highlightbackground=TERMINAL_HIGHLIGHT_BG,
        highlightcolor=TERMINAL_FG, takefocus=True, padx=10, pady=6
    )

def focus_button(idx: int):
    global focus_idx
    if not button_list:
        return
    focus_idx = max(0, min(idx, len(button_list) - 1))
    try:
        button_list[focus_idx].focus_set()
    except Exception:
        pass

def on_key_left(event=None):
    if button_list:
        focus_button((focus_idx - 1) % len(button_list))

def on_key_right(event=None):
    if button_list:
        focus_button((focus_idx + 1) % len(button_list))

def on_key_enter(event=None):
    if button_list:
        try:
            button_list[focus_idx].invoke()
        except Exception:
            pass

root.bind('<Left>', on_key_left)
root.bind('<Right>', on_key_right)
root.bind('<Return>', on_key_enter)
root.bind('<KP_Enter>', on_key_enter)
root.bind('<space>', on_key_enter)

def show(node_id):
    global button_list, _end_html_opened, _current_image_name, _last_img_size, user_name, has_previous_errors
    
    # Traquer les erreurs aux questions 1 et 2
    if node_id in ["cas_erreur_q1", "cas_erreur_q2"]:
        has_previous_errors = True
    
    # Rediriger vers jean_michel_enerve si erreur √† Q3 apr√®s des erreurs pr√©c√©dentes
    if node_id == "cas_erreur_q3" and has_previous_errors:
        node_id = "jean_michel_enerve"
    
    node = STORY[node_id]

    # G√©rer l'image associ√©e au n≈ìud
    _current_image_name = node.get("image", "normal.png")
    if HAS_PIL:
        _load_image(_current_image_name)
    _last_img_size = None  # Force le rechargement
    _resize_image()

    # Mettre √† jour le texte dans la zone scrollable
    text_area.configure(state='normal')
    text_area.delete('1.0', 'end')
    try:
        formatted = node["text"].format(name=user_name)
    except Exception:
        formatted = node["text"]
    text_area.insert('1.0', formatted)
    text_area.configure(state='disabled')
    text_area.yview_moveto(0)

    # Recr√©er les widgets dans btn_frame
    for w in btn_frame.winfo_children():
        w.destroy()
    button_list = []

    # Si le n≈ìud demande une entr√©e (ex: pr√©nom), on ajoute un Entry
    input_key = node.get("input_key")
    entry_var, entry_widget = None, None
    if input_key:
        entry_var = tk.StringVar()
        entry_widget = tk.Entry(
            btn_frame, textvariable=entry_var,
            bg=TERMINAL_BG, fg=TERMINAL_FG, insertbackground=TERMINAL_FG,
            font=TERMINAL_FONT, relief='flat', borderwidth=1, width=30
        )
        entry_widget.grid(row=0, column=0, columnspan=4, padx=6, pady=(4, 6), sticky='w')

    if node["choices"]:
        for idx, (label, next_id) in enumerate(node["choices"]):
            # D√©terminer la commande selon le contexte
            if input_key:
                def _on_validate(nid=next_id, var=entry_var):
                    global user_name
                    val = (var.get() if var else "").strip()
                    if not val:
                        root.bell()
                        return
                    user_name = val
                    show(nid)
                cmd = _on_validate
            elif node_id == 'end':
                def _cmd(nid=next_id):
                    global _end_html_opened
                    if not _end_html_opened:
                        _end_html_opened = True
                        # Appel direct pour garantir l'affichage du screamer
                        _show_screamer_overlay()
                    show(nid)
                cmd = _cmd
            else:
                cmd = partial(show, next_id)
            
            btn = _create_button(btn_frame, f"> {label}", cmd)
            btn.grid(row=(1 if input_key else 0), column=idx, padx=6)
            button_list.append(btn)
        
        root.after(0, entry_widget.focus_set if entry_widget else lambda: focus_button(0))
    else:
        btn = _create_button(btn_frame, "> Quitter", root.destroy)
        btn.grid(row=0, column=0, padx=6)
        button_list = [btn]
        root.after(0, lambda: focus_button(0))

    # Ne pas d√©clencher automatiquement ici: le screamer doit se lancer apr√®s l'action (clic)

# D√©marrer avec la premi√®re sc√®ne
show("start")

# Lancer la boucle principale
# Remonter l'image encore une fois apr√®s la mise en page initiale
root.after(0, image_frame.lift)
root.mainloop()
